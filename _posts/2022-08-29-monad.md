---
title:       "Monads"
description: "A non-mathematical introduction to Monads"
date:        2022-08-29 00:00:00 +0000
permalink:   /posts/2022-08-29/Monads
categories:
  - software
  - scala
tags:
  - software
  - scala
  - monad
---

A non-mathematical introduction to Monads.

Read [Functor]({% post_url 2022-08-29-functor %}) first!

Monads are everywhere: `IO`, `List`, `Option` and many others. Code working with databases, performing HTTP requests, publishing messages on queues, all return `IO` or something equivalent in functional codebases.

Here is a real-world example, slightly modified to protect the guilty, making calls to remote services and queues.

```scala
def completeSubscription(token: String, id: UserId): IO[Unit] =
  for {
    now      <- IO.realTimeInstant            // IO[Instant]
    token    <- createToken(tokenString, now) // IO[Token]
    _        <- activate(now, token, id) now) // IO[Unit]
    _        <- entitleUser(id, token)        // IO[Unit]
    _        <- sendSignupEmail(id, token)    // IO[Unit]
  } yield ()
```

(Remember that `for-comprehensions` in Scala is just syntactic sugar for `map` and `flatMap`.)

Here is a simpler example:

```scala
def foo(x: IO[Int], y: IO[Int]): IO[Int] =
  for {
    xv <- x
    yv <- y
  } yield xv + yv
```

which desugars to:

```scala
def sum(x: IO[Int], y: IO[Int]): IO[Int] =
  x.flatMap(xv => y.map(yv => xv + yv))
```

`sum` and `completeSubscription` do not care about `IO`, they care about the values it contains
In essence, they need a way to apply a function `A => F[B]` to `F[A]`, returning `F[B]`.

The `Monad` for `F[_]` provides such a function. Here is `sum` rewritten using a `Monad` *for any `F[_]`* that has a `Monad[F]`:

```scala
import cats.syntax.all.*

def sum[F[_]](x: F[Int], y: F[Int])(using Monad[F]): F[Int] =
  for {
    xv <- x
    yv <- y
  } yield xv + yv
```

The for-comprehension looks for `flatMap` on `x` and `y`, does not find it, and so searches for an implicit instance that can.
[Cats](https://typelevel.org/cats/) syntax provides `flatMap` using the `Monad[F]` instance.

## Writing a Monad

A `Monad` provides the function described above for some `F[_]`:

```scala
trait Monad[F[_]] {
  extension [A, B](x: F[A])
    def flatMap(f: A => F[B]): F[B]
}
```

Here are example instances for `Option` and `List`:

```scala
given Monad[Option] with {
  extension [A, B](m: Option[A])
    override def flatMap(f: A => Option[B]): Option[B] = m.flatMap(f)
}

given Monad[List] with {
  extension [A, B](m: List[A])
    override def map(f: A => List[B]): List[B] = m.flatMap(f)
}
```

Remember that Scala's `List` and `Option` have `flatMap` functions already and are used directly in this implementation.

Your own types can play too:

```scala
final case class Blub[A](v: A)

object Blub {
  given Monad[Blub] with {
    extension [A, B](blub: Blub[A])
      override def flatMap(f: A => Blub[B]): Blub[B] = f(blub.v)
  }
}
```

## More

1. A Monad is also a [Functor]({% post_url 2022-08-29-functor %})
1. Monad has three laws:
    1. left identity: `(Monad[F].pure(x).flatMap(f)) === f(x)`
    1. right identity: `(m.flatMap(Monad[F].pure(_))) === m`
    1. associativity: `(m.flatMap(f)).flatMap(g) === m.flatMap(x => f(x).flatMap(g))`
1. Learn about this in [pictures](https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html) (Haskell)
1. [What we talk about when we talk about monads.pdf](http://tomasp.net/academic/papers/monads/monads-programming.pdf)
